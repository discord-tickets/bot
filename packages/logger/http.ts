// import type { BunRequest } from 'bun';
import type { Logger } from 'leekslazylogger';
import { randomBytes } from 'node:crypto';

export type DecoratedRequest = Request & {
	$logger: {
		id: string;
		ip?: string;
		start: number;
	}
}

export const nodeId = process.env.NODE_ID || randomBytes(2).toString('hex');

export let counter = 0;

export default class HTTPLoggingMiddleware {
	public log: Logger;

	constructor(logger: Logger) {
		this.log = logger;
	}

	decorate(server: Bun.Server, req: Request): DecoratedRequest {
		const decorated = req as DecoratedRequest;
		decorated.$logger = {
			id: `req-${nodeId}-${(counter++).toString(36)}`,
			ip: this.resolveIP(server, req),
			start: performance.now(),
		};
		return decorated;
	}

	getDurationColour(duration: number) {
		if (duration < 100) return '&a'; // light green = fast
		if (duration < 500) return '&e'; // light yellow = slightly slow
		if (duration < 1000) return '&c'; // light red = slow
		return '&4'; // dark red = very slow
	}

	getStatusColour(status: number) {
		switch ((status / 100) | 0) {
		case 5: // red = error
			return '&4';
		case 4: // yellow = warning
			return '&6';
		case 3: // cyan = redirect
			return '&3';
		case 2: // green = success
			return '&2';
		}
	}

	logError(err: unknown, req: DecoratedRequest) {
		this.log.error.http?.({
			error: err,
			id: req.$logger.id,
		});
	}

	logRequest(req: DecoratedRequest) {
		this.log.info.http?.(`${req.$logger.id} &7${req.$logger.ip ?? '?'}&b &m-->&r&b ${req.method} ${new URL(req.url).pathname}`);
		this.log.verbose.http?.(req.$logger.id, Object.fromEntries(req.headers));
	}

	logResponse(req: DecoratedRequest, res: Response) {
		const duration = performance.now() - req.$logger.start;
		this.log.info.http?.(`${req.$logger.id} ${this.getStatusColour(res.status)}${res.status}&b &m<--&r ${this.getDurationColour(duration)}${Math.round(duration)}ms`);
	}

	createNativeWrapper(handler: (req: Request) => Promise<Response>) {
		return async (req: Request, server: Bun.Server): Promise<Response> => {
			const decorated = this.decorate(server, req);
			this.logRequest(decorated);
			let res;
			try {
				res = await handler.call(server, decorated);
				this.logResponse(decorated, res);
				return res;
			} catch (error) {
				this.logError(error, decorated);
				// error responses are not logged because they are generated by the server
				throw error;
			}
		};
	}

	resolveIP(server: Bun.Server, req: Request) {
		return req.headers.get('x-forwarded-for')?.split(',')[0]?.trim() ||
			req.headers.get('cf-connecting-ip') ||
			req.headers.get('x-real-ip') ||
			server.requestIP(req)?.address;
	}
}
